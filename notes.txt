Virtual Env : a setup in which we can use different versions of the same application to work on different projects and use different features.
To create a virtual env :  python3 -m venv <name>

Helps you isolate your project dependencies

To activate your Venv : source <name>/bin/activate
To deactivate : deactivate

Install FastAPI: pip install FastAPI

Note: When pushing your code into remote repo's, we dont need to track/store venv file in the repo. To avoid this we will .gitignore file.
Instead use requirements.txt file to track all your dependencies/packages in the project. Use this file to install dependencies.

To create a requirements.txt file: pip freeze > requirements.txt 
To install packages/dependencies from requirements.txt file we use : pip install -r requirements.txt 

Note: How to use .gitignore ( create manually - a file named .gitignore in the root ) 
gitignore is a file that contains a list of file names or folders that we want to avoid in our git repo.

To creat a FastAPI  project repo: 
Go to github and manually create a public repo
follow all the commands and push the code.
Whenever you make changes, save the file and follow below cmd: 
git add . - adds all the files from the project to the local staging.
git commit -m "message" -  commits the code
git push -u origin main - pushes the code

To run FastAPI application, use this command : uvicorn main:apps

Whenever we make changes to our code, we dont need to restart the server instead we can use this command :
uvicorn main:apps --reload 

What are decorators in python?
That @something syntax in Python is called a "decorator".
You put it on top of a function. Like a pretty decorative hat.
A "decorator" takes the function below and does something with it.
In our case, this decorator tells **FastAPI** that the function below corresponds to the **path** / with an **operation** get.

Postman - A tool to test our application.
Among the other HTTP requests: we used get and post to retrive the data from the API.
To retrieve the body data created in postman in VSC:
Within the path operation function we can assign variable - def def create_posts(payLoad: dict = Body(...)):
print(payLoad)
This will import the lib Body from the fastapi; 
extracts all the fields ie data from the Body, converts into python dict, stores inside the variable payload.

Pydantic:
Lib used to define schema
First we define a class, extend Basemodel - class Post(BaseModel):
Instead of extrctg payload, ref the post and save it
fastapi will automatically validate the data from the client based off the pydantic model.
each pydantic model has method called .dict
pad -> dict = new_post.dict()

CRUD : create, read, update, delete.
for the above methods we use the following http requests: get, put, patch, delete.

We have created an 'id' to be stored in our local memory as a primary key. Create an array which python dict.
Used append to pass in what we have to append to the array to get the newly created entry with an id.

To restart the server after adding a file in any newly created folder: uvicorn <foldername>.main:app --reload 
Setting up our DB - Postgres:
